let data,dbPath=null;const{KeyObject:KeyObject}=require("crypto"),fs=require("fs"),isObject=t=>"object"==typeof t&&null!==t&&!isArray(t),isArray=t=>Array.isArray(t);function newID(){return((new Date).getTime()/1e3|0).toString(16)+"xxxxxxxxxxxxxxxx".replace(/[x]/g,(()=>(16*Math.random()|0).toString(16))).toLowerCase()}async function syncData(){try{data=JSON.parse(await fs.readFileSync(dbPath))}catch{}}async function save(){try{await fs.writeFileSync(dbPath,JSON.stringify(data))}catch(t){console.log(t)}}exports.init=async(t,e)=>{dbPath=t||__dirname+"/db.json";try{data=JSON.parse(await fs.readFileSync(dbPath))}catch(t){"ENOENT"===t.code?await fs.writeFileSync(dbPath,"{}"):console.log(t)}},exports.insert=async(t,e)=>{try{if(!t)throw"Collection not specified";if(!e)throw"Data not specified";if(!isObject(e)&&!isArray(e))throw"Data should be an Object";await syncData(),t=t.trim(),data[t]?isArray(e)?e.forEach((e=>{data[t].push({id:newID(),...e})})):data[t].push({id:newID(),...e}):isArray(e)?(data[t]=[],e.forEach((e=>{data[t].push({id:newID(),...e})}))):data[t]=[{id:newID(),...e}],await save()}catch(t){console.log(t)}};const condiSym={$ge:(t,e,a)=>e[t]>=a,$g:(t,e,a)=>e[t]>a,$l:(t,e,a)=>e[t]<a,$le:(t,e,a)=>e[t]<=a};function goDeep(t,e,a){return"string"==typeof e?goDeep(t,e.split("."),a):1==e.length&&void 0!==a?t[e[0]]?t[e[0]]=a:0==e.length?t:goDeep(t[e[0]],e.slice(1),a):void 0}function checkConditions(t,e){let a=Object.keys(e)[0],i=e[a];if(isObject(i)){let e=!0;for(specialCondi in i)if(!condiSym[specialCondi](a,t,i[specialCondi])){e=!1;break}return e}return t[a]===i}exports.find=async(t,e)=>new Promise((async(a,i)=>{try{if(!t)throw"Collection not specified";if(!isObject(e)&&!isArray(e))throw"Data should be an Object";if(await syncData(),0===Object.keys(e).length)data[t]?a(data[t]):a([]);else{const i=isArray(e)?1:2;let s=[];for(let a=0;a<data[t].length;a++)if(1===i){let i=!0;for(let s=0;s<e.length;s++)checkConditions(data[t][a],e[s])||(i=!1);i&&s.push(data[t][a])}else 2===i&&checkConditions(data[t][a],e)&&s.push(data[t][a]);a(s)}}catch(t){console.log(t),i(t)}}));const mutateSym={$push(t,e,a){isArray(t[e])&&a.forEach((a=>{t[e].push(a)}))}};function mutateItem(t,e){if(isArray(e))e.forEach((e=>{let a=Object.keys(e)[0],i=e[a],s=Object.keys(i)[0];mutateSym.hasOwnProperty(s)?mutateSym[s](t,a,i[s]):t[a]=i}));else if(isObject){let a=Object.keys(e)[0],i=e[a],s=Object.keys(i)[0];mutateSym.hasOwnProperty(s)?mutateSym[s](t,a,i[s]):t[a]=i}}exports.update=async(t,e,a)=>new Promise((async(i,s)=>{try{if(!t)throw"Collection not specified";if(!isObject(e)&&!isArray(e))throw"Data should be an Object";if(!isObject(a)&&!isArray(a))throw"Data should be an Object";if(await syncData(),0===Object.keys(e).length)data[t]?data[t].forEach((t=>{mutateItem(t,a)})):i();else{const s=isArray(e)?1:2;for(let i=0;i<data[t].length;i++)if(1===s){let s=!0;for(let a=0;a<e.length;a++)checkConditions(data[t][i],e[a])||(s=!1);s&&mutateItem(data[t][i],a)}else 2===s&&checkConditions(data[t][i],e)&&mutateItem(data[t][i],a);await save(),i()}}catch(t){console.log(t),s(t)}})),exports.delete=async(t,e,a)=>new Promise((async(i,s)=>{try{if(!t)throw"Collection not specified";if(!isObject(e)&&!isArray(e))throw"Data should be an Object";if(await syncData(),0===Object.keys(e).length)if(data[t]){if(!0!==a)throw"You are trying to delete everything, add true to 3rd parameter to confirm this operation";data[t]=[]}else i();else{const a=isArray(e)?1:2;for(let i=data[t].length-1;i>=0;i--)if(1===a){let a=!0;for(let s=0;s<e.length;s++)checkConditions(data[t][i],e[s])||(a=!1);a&&data[t].splice(i,1)}else 2===a&&checkConditions(data[t][i],e)&&data[t].splice(i,1);await save(),i()}}catch(t){console.log(t),s(t)}}));
